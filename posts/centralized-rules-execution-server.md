---
authors: 
- Mallik Sambaraju
- Amine Alami
tags:
- Rules
- Kie
- Drools
- JHipster
- AWS ECS
- Spring Boot
date: 2010-01-23T10:00:00.000Z
title: Centralized Rules Engine on AWS ECS
---

## Introduction
As software engineers we architect and develop many real world applications solving many business problems, and in those applications we add business logic to solve various issues. Often this business logic is difficult to implement in application code and often these business rules keep on changing and hard to maintain.

## Why rules engine
A rules engine may be handy in certain cases where the business logic keep on changing, there is no easy solution to implement the logic in the code, the code becomes cluttered or may be the business analysts want an easy way to maintain this logic. Apart from these, rules engines implement rules execution algorithms such as rete algorithm which are more efficient than traditional if..else or switch statememts.

## The problem
At one of our recent customer's location, we were tasked to resolve a problem and the application has to look into more than hundred different scenarios to come up with a result. Also the customer wanted to have a provision to maintain the rules seperately as the rules can change quite often.

## The solution
We decided to use a centralized rules execution engine based on Jboss Drools (Kie execution server) to make the rules engine a loosly coupled application, to maintain the rules outside of the business application, to make the rules engine available to other applications in the organization which has similar use cases.

## Architecture
The version 1 of the rules engine is designed to adhere to the customer's infrastructure, ability to use the customer's source control repository, security standards and CI/CD process. The solution is designed to auto-recover in case of rules engine restarts/crashes.

- ### Deployment architecture
The rules engine is deployed into the existing AWS ECS infrastructure as a spring boot application. The service has access to AWS EFS service so that it can store its state in the metadata file on the network so that it can recover from the unexpected restarts. 

The service has access to the internal maven repository so that it can access the rules artifacts and load them as KieContainers. Each KieContainer represents one set of rules maintained by a project team. 

The service has access to customer's LDAP to support security and authorizations, so that only the authorized users have access to update the rules.

![alt](https://raw.githubusercontent.com/msambaraju/blog-usa/master/images/2019/01/Kie_Server.png)

- ### Development architecture
Each development team is responsible for the maintenance of their rules, the rules are maintained in the git repository as maven projects. The project contains the rules files in .drl or .xls formats and any dependencies are maintained in the pom.xml such as POJO's used in the rules, or any other utilities used in the rules files.

The project is configured to to built and packaged using the existing Jenkins pipeline. The built artifact is pushed into the internal maven repository and it complies to the existing release management process.

![alt](https://raw.githubusercontent.com/msambaraju/blog-usa/master/images/2019/01/Kie_Container_Process.png)

## Implimentation
The base spring boot application is generated by JHipster so that the capabilities provided by JHipster are already part of the generated application.For more information on JHipster visit [JHipster](https://www.jhipster.tech). JHipster is already standardized at the customer location to support existing infrastructure.

The kie spring boot starter project is included as dependency in the pom.xml and other suppoprting dependencies are added accordingly

```xml
        <dependency>
	      <groupId>org.kie</groupId>
	      <artifactId>kie-server-spring-boot-starter-drools</artifactId>
	      <version>7.15.0.Final</version>
	    </dependency>
```

```yaml
Configuration changes in application.yml
kieserver:
    serverId: CustomerRulesEngine
    serverName: Customer KIE Server
    restContextPath: /rest
    drools:
        enabled: true
    dmn:
        enabled: true
    jbpm:
        enabled: false
    jbpmui:
        enabled: false
    casemgmt: 
        enabled: false
    optaplanner:
        enabled: false
    location: http://${server.address}:${server.port}${cxf.path}/server

cxf:
    path: /rest

jbpm: 
    executor:
        enabled: false
```

The execution server is configured to use the custom maven settings file and custom repository to store metadata.

```
kie.maven.settings.custom = /usr/kieserver/settings.xml
org.kie.server.repo = /mnt/efs/kie/repository (this is the mount on the AWS EFS)

```

## Future
The future versions of the application is to enable scaling of the rules execution server and have a front end router application to route the rule execution requests and support the rules workbench.